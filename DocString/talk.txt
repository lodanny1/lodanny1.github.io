AWSTemplateFormatVersion: '2010-09-09'
Description: HTTP API + Cognito JWT authorizer + two Lambdas (files list, create download) - pure CloudFormation

Parameters:
  AmplifyOrigin:
    Type: String
    Default: https://main.d28wvz3bs3pz1c.amplifyapp.com
    Description: Exact site origin (no trailing slash). Add localhost in CORS if needed.
  UserPoolId:
    Type: String
    Default: us-west-1_nvEoATfLg
    Description: Cognito User Pool ID (region must match this stack region).
  AppClientId:
    Type: String
    Default: 449iodh2hukvctej9vuupfkmv
    Description: Cognito App Client ID (audience value).
  TableName:
    Type: String
    Default: Metadata-251985477703-us-west-1
  BucketName:
    Type: String
    Default: severless-proj-uploads-251985477703-us-west-1
  UrlExpiresSeconds:
    Type: Number
    Default: 900
  StageName:
    Type: String
    Default: prod

Mappings: {}

Resources:
  # ---------------- Logs ----------------
  FilesListLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-FilesList
      RetentionInDays: 14

  CreateDownloadLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-CreateDownload
      RetentionInDays: 14

  # ---------------- IAM Role for Lambdas ----------------
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-LambdaRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AppDdbS3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: [ dynamodb:Scan ]
                Resource: !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${TableName}
              - Effect: Allow
                Action: [ s3:GetObject ]
                Resource: !Sub arn:aws:s3:::${BucketName}/*

  # ---------------- Lambda: GET /files/list ----------------
  FilesListFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-FilesList
      Runtime: nodejs20.x
      Architectures: [ arm64 ]
      Handler: index.handler
      Role: !GetAtt LambdaRole.Arn
      Timeout: 10
      Environment:
        Variables:
          TABLE_NAME: !Ref TableName
          BUCKET_NAME: !Ref BucketName
          URL_EXPIRES_SEC: !Ref UrlExpiresSeconds
          ORIGIN: !Ref AmplifyOrigin
      Code:
        ZipFile: |
          import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
          import { DynamoDBDocumentClient, ScanCommand } from "@aws-sdk/lib-dynamodb";

          const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}), { marshallOptions: { removeUndefinedValues: true }});
          const TABLE = process.env.TABLE_NAME;
          const BUCKET = process.env.BUCKET_NAME;
          const ORIGIN = process.env.ORIGIN || "*";

          const allowedOrigins = new Set([ORIGIN, "http://localhost:5173"]);

          function corsHeaders(event){
            const h = (event?.headers)||{};
            const reqOrigin = h.origin || h.Origin;
            const allow = allowedOrigins.has(reqOrigin) ? reqOrigin : ORIGIN;
            return {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": allow,
              "Access-Control-Allow-Headers": "Authorization,Content-Type"
            };
          }

          export const handler = async (event) => {
            try {
              const qs = event.queryStringParameters || {};
              const prefix = typeof qs.prefix === "string" ? qs.prefix : "";
              const limit = Math.min(Number(qs.limit || 200), 500);

              const res = await ddb.send(new ScanCommand({ TableName: TABLE, Limit: limit }));
              const items = (res.Items || [])
                .filter(it => it.bucket === BUCKET)
                .filter(it => typeof it.key === "string")
                .filter(it => prefix ? it.key.startsWith(prefix) : true)
                .filter(it => typeof it.contentType === "string" ? !it.contentType.includes("x-directory") : true)
                .filter(it => typeof it.size === "number" ? it.size > 0 : true)
                .map(it => ({
                  key: it.key,
                  bucket: it.bucket,
                  size: typeof it.size === "number" ? it.size : null,
                  contentType: it.contentType || null,
                  status: it.status || null,
                  processedAt: it.processedAt || null
                }))
                .sort((a,b) => String(b.processedAt||"").localeCompare(String(a.processedAt||"")));

              return { statusCode: 200, headers: corsHeaders(event), body: JSON.stringify({ items }) };
            } catch (err) {
              console.error("ERROR", err);
              return { statusCode: 500, headers: corsHeaders(event), body: JSON.stringify({ error: "Internal error", detail: String(err) }) };
            }
          };

      LoggingConfig:
        LogGroup: !Ref FilesListLogGroup

  # ---------------- Lambda: POST /downloads/create ----------------
  CreateDownloadFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-CreateDownload
      Runtime: nodejs20.x
      Architectures: [ arm64 ]
      Handler: index.handler
      Role: !GetAtt LambdaRole.Arn
      Timeout: 10
      Environment:
        Variables:
          BUCKET_NAME: !Ref BucketName
          URL_EXPIRES_SEC: !Ref UrlExpiresSeconds
          ORIGIN: !Ref AmplifyOrigin
      Code:
        ZipFile: |
          import { S3Client, GetObjectCommand } from "@aws-sdk/client-s3";
          import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

          const s3 = new S3Client({});
          const BUCKET = process.env.BUCKET_NAME;
          const EXPIRES = Number(process.env.URL_EXPIRES_SEC || 900);
          const ORIGIN = process.env.ORIGIN || "*";
          const allowedOrigins = new Set([ORIGIN, "http://localhost:5173"]);

          function corsHeaders(event){
            const h = (event?.headers)||{};
            const reqOrigin = h.origin || h.Origin;
            const allow = allowedOrigins.has(reqOrigin) ? reqOrigin : ORIGIN;
            return {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": allow,
              "Access-Control-Allow-Headers": "Authorization,Content-Type"
            };
          }

          export const handler = async (event) => {
            try {
              const body = event.body ? JSON.parse(event.body) : {};
              const key = body?.key;
              if (!key || typeof key !== "string") {
                return { statusCode: 400, headers: corsHeaders(event), body: JSON.stringify({ error: "Body must include { key: '<s3-object-key>' }" }) };
              }

              const url = await getSignedUrl(s3, new GetObjectCommand({ Bucket: BUCKET, Key: key }), { expiresIn: EXPIRES });

              return { statusCode: 200, headers: corsHeaders(event), body: JSON.stringify({ url, expiresIn: EXPIRES, bucket: BUCKET, key }) };
            } catch (err) {
              console.error("ERROR", err);
              return { statusCode: 500, headers: corsHeaders(event), body: JSON.stringify({ error: "Internal error", detail: String(err) }) };
            }
          };

      LoggingConfig:
        LogGroup: !Ref CreateDownloadLogGroup

  # ---------------- HTTP API (v2) with CORS ----------------
  HttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub ${AWS::StackName}-HttpApi
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins:
          - !Ref AmplifyOrigin
          # - http://localhost:5173   # uncomment for local dev
        AllowHeaders:
          - Authorization
          - Content-Type
        AllowMethods:
          - GET
          - POST
          - OPTIONS
        ExposeHeaders:
          - Content-Disposition
        MaxAge: 86400
        AllowCredentials: false

  # ---------------- JWT Authorizer ----------------
  HttpApiAuthorizer:
    Type: AWS::ApiGatewayV2::Authorizer
    Properties:
      ApiId: !Ref HttpApi
      AuthorizerType: JWT
      IdentitySource:
        - "$request.header.Authorization"
      Name: CognitoJWT
      JwtConfiguration:
        Audience:
          - !Ref AppClientId
        Issuer: !Sub https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPoolId}

  # ---------------- Lambda Integrations ----------------
  FilesListIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt FilesListFunction.Arn
      PayloadFormatVersion: '2.0'

  CreateDownloadIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt CreateDownloadFunction.Arn
      PayloadFormatVersion: '2.0'

  # ---------------- Routes ----------------
  FilesListRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "GET /files/list"
      AuthorizationType: JWT
      AuthorizerId: !Ref HttpApiAuthorizer
      Target: !Sub integrations/${FilesListIntegration}

  CreateDownloadRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "POST /downloads/create"
      AuthorizationType: JWT
      AuthorizerId: !Ref HttpApiAuthorizer
      Target: !Sub integrations/${CreateDownloadIntegration}

  # ---------------- Stage ----------------
  HttpApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      StageName: !Ref StageName
      ApiId: !Ref HttpApi
      AutoDeploy: true

  # ---------------- Lambda invoke permissions ----------------
  FilesListPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt FilesListFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/*/*

  CreateDownloadPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt CreateDownloadFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/*/*

Outputs:
  InvokeUrl:
    Description: Base invoke URL (set this as VITE_API_BASE, include /${StageName})
    Value: !Sub https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}
  FilesListFunctionArn:
    Value: !GetAtt FilesListFunction.Arn
  CreateDownloadFunctionArn:
    Value: !GetAtt CreateDownloadFunction.Arn
