https://main.d28wvz3bs3pz1c.amplifyapp.com/


// index.mjs
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, ScanCommand } from "@aws-sdk/lib-dynamodb";

const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}), {
  marshallOptions: { removeUndefinedValues: true }
});

// === Your schema (from message) ===
const TABLE = process.env.TABLE_NAME;
const BUCKET = process.env.BUCKET_NAME;

// Attribute names in your table:
const PK = 'pk';
const SK = 'sk';
const ATTR_BUCKET = 'bucket';
const ATTR_KEY = 'key';
const ATTR_SIZE = 'size';
const ATTR_TYPE = 'contentType';
const ATTR_STATUS = 'status';
const ATTR_PROCESSED = 'processedAt';

// Simple CORS (OK for Bearer-token APIs)
const CORS = { "Access-Control-Allow-Origin": "*", "Access-Control-Allow-Headers": "Authorization,Content-Type" };

export const handler = async (event) => {
  try {
    const qs = event.queryStringParameters || {};
    const limit = Math.min(Number(qs.limit || 100), 500);
    const prefix = typeof qs.prefix === 'string' ? qs.prefix : ''; // e.g., 'analytics/'
    // Weâ€™ll filter pk that begins with FILE#<bucket>/<prefix>
    const wantPrefix = `FILE#${BUCKET}/${prefix}`;

    // Scan + filter (no GSI provided)
    // NOTE: FilterExpression reduces items AFTER read; fine for PoC sizes.
    const cmd = new ScanCommand({
      TableName: TABLE,
      Limit: limit,
      FilterExpression:
        "begins_with(#pk, :p) AND #sk = :sk AND (#sz > :z OR attribute_not_exists(#sz)) AND (attribute_not_exists(#ct) OR NOT contains(#ct, :dir))",
      ExpressionAttributeNames: {
        "#pk": PK, "#sk": SK, "#sz": ATTR_SIZE, "#ct": ATTR_TYPE
      },
      ExpressionAttributeValues: {
        ":p": wantPrefix,
        ":sk": "META#v1",
        ":z": 0,
        ":dir": "x-directory"
      }
    });

    const res = await ddb.send(cmd);
    const items = (res.Items || [])
      .map((raw) => ({
        // Normalize to a stable shape for the UI
        key: raw[ATTR_KEY],               // e.g., "analytics/John_Doe_Cost.csv"
        bucket: raw[ATTR_BUCKET],         // "severless-proj-uploads-..."
        size: raw[ATTR_SIZE] ?? null,
        contentType: raw[ATTR_TYPE] ?? null,
        status: raw[ATTR_STATUS] ?? null,
        processedAt: raw[ATTR_PROCESSED] ?? null,
        // extras you may want later:
        _pk: raw[PK],
        _sk: raw[SK]
      }))
      // sort by processedAt desc if present
      .sort((a, b) => String(b.processedAt || '').localeCompare(String(a.processedAt || '')));

    return {
      statusCode: 200,
      headers: { "Content-Type": "application/json", ...CORS },
      body: JSON.stringify({ items })
    };
  } catch (err) {
    console.error(err);
    return {
      statusCode: 500,
      headers: { "Content-Type": "application/json", ...CORS },
      body: JSON.stringify({ error: "Internal error", detail: String(err) })
    };
  }
};


--------

// index.mjs
import { S3Client, GetObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

const s3 = new S3Client({});
const CORS = { "Access-Control-Allow-Origin": "*", "Access-Control-Allow-Headers": "Authorization,Content-Type" };

export const handler = async (event) => {
  try {
    const { BUCKET_NAME, URL_EXPIRES_SEC } = process.env;
    const expiresIn = Number(URL_EXPIRES_SEC || 900);

    const body = event.body ? JSON.parse(event.body) : {};
    const key = body?.key; // e.g., "John_Doe_Contract.pdf" or "analytics/John_Doe_Cost.csv"

    if (!key || typeof key !== 'string') {
      return {
        statusCode: 400,
        headers: { "Content-Type": "application/json", ...CORS },
        body: JSON.stringify({ error: "Body must include: { key: '<s3-object-key>' }" })
      };
    }

    const cmd = new GetObjectCommand({ Bucket: BUCKET_NAME, Key: key });
    const url = await getSignedUrl(s3, cmd, { expiresIn });

    return {
      statusCode: 200,
      headers: { "Content-Type": "application/json", ...CORS },
      body: JSON.stringify({ url, expiresIn, bucket: BUCKET_NAME, key })
    };
  } catch (err) {
    console.error(err);
    return {
      statusCode: 500,
      headers: { "Content-Type": "application/json", ...CORS },
      body: JSON.stringify({ error: "Internal error", detail: String(err) })
    };
  }
};



